<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>¿Te atreves? – Disco Dash</title>
<style>
  :root{
    --ui-bg: rgba(0,0,0,0.42); --ui-text:#fff; --accent:#8b5cf6; --accent2:#00ffd5; --danger:#ff4d6d; --gold:#ffd166;
    --pad-top: env(safe-area-inset-top, 0px);
    --pad-right: env(safe-area-inset-right, 0px);
    --pad-bottom: env(safe-area-inset-bottom, 0px);
    --pad-left: env(safe-area-inset-left, 0px);
  }
  html,body{height:100%;margin:0;background:#05060c;color:var(--ui-text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,'Helvetica Neue',Arial,"Noto Sans",sans-serif;overflow:hidden;overscroll-behavior:none;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none;}
  .root{width:100vw;height:100dvh;display:grid;place-items:center;padding:var(--pad-top) var(--pad-right) var(--pad-bottom) var(--pad-left);box-sizing:border-box;}
  .game-wrap{position:relative;width:100%;height:100%;}
  .stage{position:relative;width:100%;height:100%;}
  /* Contenedor lógico 1280x720 escalado y CENTRADO por JS */
  .stage-inner{position:absolute;left:0;top:0;width:1280px;height:720px;border-radius:16px;overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,.65),inset 0 0 0 1px rgba(255,255,255,.06);background:transparent;transform-origin:top left;}
  canvas{width:1280px;height:720px;display:block;background:transparent;touch-action:none;}

  /* HUD */
  .hud{position:absolute;left:12px;right:12px;top:10px;display:grid;grid-template-columns:1fr auto;gap:12px;pointer-events:none;}
  .panel{background:var(--ui-bg);backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:8px 12px;box-shadow:0 8px 24px rgba(0,0,0,.35);}
  .progress{height:10px;border-radius:6px;overflow:hidden;position:relative;box-shadow:inset 0 0 0 1px rgba(255,255,255,.06);background:linear-gradient(90deg,rgba(255,255,255,.06),rgba(255,255,255,.02));}
  .progress>.bar{height:100%;width:0%;background:linear-gradient(90deg,#8b5cf6,#00ffd5 40%,#9bffd4 60%,#fffcc0 100%);box-shadow:0 0 18px #8b5cf6;}
  .stats{font-size:14px;line-height:1.2;} .stats b{color:#d6cbff;}
  .status-tag{padding:4px 10px;border-radius:10px;font-weight:800;letter-spacing:.5px;font-size:12px;background:linear-gradient(180deg,rgba(0,0,0,.35),rgba(0,0,0,.15));border:1px solid rgba(255,255,255,.08);}

  /* Overlays (menú / mensajes) */
  .overlay{position:absolute;inset:0;display:grid;place-items:center;text-align:center;padding:24px;pointer-events:none;}
  .overlay .card{pointer-events:auto;padding:18px 22px;border-radius:14px;background:linear-gradient(180deg,rgba(0,0,0,.58),rgba(0,0,0,.32));border:1px solid rgba(255,255,255,.08);box-shadow:0 24px 64px rgba(0,0,0,.55);max-width:min(92%,1100px);}
  .title{font-size:clamp(22px,3.8vw,44px);margin:8px 0 6px;font-weight:900;letter-spacing:.3px;}
  .subtitle{font-size:clamp(14px,2vw,18px);opacity:.9;}
  .big{font-size:clamp(22px,4vw,54px);font-weight:900;text-shadow:0 6px 30px rgba(0,0,0,.6);}
  .btns{display:flex;gap:12px;justify-content:center;flex-wrap:wrap;margin-top:14px;}
  .btn{cursor:pointer;background:linear-gradient(180deg,#1e293b,#0b1220);color:#dff9ff;border:1px solid rgba(255,255,255,.1);padding:12px 16px;border-radius:12px;font-weight:800;letter-spacing:.3px;box-shadow:0 10px 24px rgba(0,0,0,.4);transition:transform .06s ease,filter .15s ease;font-size:16px;}
  .btn:hover{filter:brightness(1.1);} .btn:active{transform:translateY(1px) scale(.995);} .btn[disabled]{opacity:.6;cursor:not-allowed;}
  .chars{display:grid;grid-template-columns:repeat(4,minmax(100px,1fr));gap:12px;margin-top:12px;}
  .char{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:6px;position:relative;}
  .char img{width:100%;height:120px;object-fit:cover;border-radius:10px;display:block;}
  .char:hover{outline:2px solid rgba(139,92,246,.45);} .char.sel{outline:3px solid #8b5cf6;box-shadow:0 0 24px rgba(139,92,246,.35) inset;}
  .emoji{display:inline-block;font-size:clamp(28px,6vw,72px);filter:drop-shadow(0 8px 24px rgba(139,92,246,.6));animation:bob 1.6s ease-in-out infinite;}
  @keyframes bob{0%,100%{transform:translateY(0);}50%{transform:translateY(-8px) rotate(-2deg);}}
  .cover{display:block;width:min(86vw,780px);max-height:48vh;object-fit:cover;border-radius:12px;box-shadow:0 14px 40px rgba(0,0,0,.5);border:1px solid rgba(255,255,255,.08);margin:0 auto 8px;}
  .victory-photo,.death-photo{display:block;width:min(86vw,560px);max-height:40vh;object-fit:cover;border-radius:10px;margin:8px auto 8px;box-shadow:0 12px 32px rgba(0,0,0,.5);border:1px solid rgba(255,255,255,.08);}

  /* Overlay de rotación (bloquea el juego en vertical) */
  .rotate-overlay{position:fixed;inset:0;background:#05060c;display:none;align-items:center;justify-content:center;z-index:9999;padding:24px;box-sizing:border-box;color:#fff;text-align:center;}
  .rotate-overlay.show{display:flex;}
  .rotate-box{max-width:560px;border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:22px;background:linear-gradient(180deg,rgba(0,0,0,.6),rgba(0,0,0,.3));box-shadow:0 24px 64px rgba(0,0,0,.55);}
  .rotate-title{font-size:clamp(22px,5vw,34px);font-weight:900;margin:0 0 8px;}
  .rotate-sub{opacity:.9}
</style>
</head>
<body>
<div class="root">
  <div class="game-wrap" aria-live="polite">
    <div class="stage" id="stage">
      <div class="stage-inner" id="stageInner">
        <canvas id="game" width="1280" height="720" aria-label="¿Te atreves? Juego rítmico de discoteca. Controles: toca para saltar (doble salto). R reinicia."></canvas>

        <!-- HUD -->
        <div class="hud" aria-hidden="true">
          <div class="panel">
            <div class="progress" title="Progreso nivel">
              <div class="bar" id="progressBar"></div>
            </div>
            <div class="stats" id="stats"></div>
          </div>
          <div class="status-tag" id="statusTag">MENÚ</div>
        </div>

        <!-- Overlays -->
        <div class="overlay" id="overlay" style="display:none">
          <div class="card" id="overlayCard"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Overlay que bloquea en vertical -->
<div class="rotate-overlay" id="rotateOverlay">
  <div class="rotate-box">
    <div class="rotate-title">Gira el móvil</div>
    <div class="rotate-sub">Este juego se juega <b>en horizontal</b>. Rota el dispositivo para empezar.</div>
  </div>
</div>

<script>
(() => {
  'use strict';

  /* ========== MOTOR DE ESCALADO (Landscape-only, 1280x720) ========== */
  const BASE_W = 1280, BASE_H = 720;
  const stage = document.getElementById('stage');
  const inner = document.getElementById('stageInner');
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:true, desynchronized:true });
  const rotateOverlay = document.getElementById('rotateOverlay');

  let DPR = 1, S = 1, portraitBlocked = false;

  function isPortrait() {
    const vv = window.visualViewport || { width: window.innerWidth, height: window.innerHeight };
    return vv.height > vv.width; // estricto: vertical = bloqueado
  }

  function fit() {
    const vv = window.visualViewport || { width: window.innerWidth, height: window.innerHeight };
    const availW = Math.min(window.innerWidth, vv.width);
    const availH = Math.min(window.innerHeight, vv.height);

    // ¿Bloquear por orientación?
    portraitBlocked = isPortrait();
    rotateOverlay.classList.toggle('show', portraitBlocked);

    // Si está bloqueado, aún calculamos para que al girar entre suave
    const targetW = BASE_W, targetH = BASE_H;
    S = Math.min(availW / targetW, availH / targetH);

    // Centrado: posicionamos el contenedor lógico y lo escalamos
    const viewW = targetW * S;
    const viewH = targetH * S;
    const left = Math.max(0, (availW - viewW) / 2);
    const top  = Math.max(0, (availH - viewH) / 2);

    inner.style.left = left + 'px';
    inner.style.top  = top  + 'px';
    inner.style.transform = `scale(${S})`; // origin = top-left

    // HiDPI nítido
    DPR = Math.min(window.devicePixelRatio || 1, 3);
    const wantW = Math.round(BASE_W * DPR);
    const wantH = Math.round(BASE_H * DPR);
    if (canvas.width !== wantW || canvas.height !== wantH) {
      canvas.width = wantW; canvas.height = wantH;
    }
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }

  // No interceptar toques globalmente: SOLO el canvas
  // (así los botones de overlay siguen funcionando)
  let lastTouchEnd = 0;
  canvas.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 350) e.preventDefault(); // evita doble-tap zoom dentro del canvas
    lastTouchEnd = now;
  }, {passive:false});

  // Bloquear el juego si está en vertical: no procesar inputs ni actualizar
  function playingAllowed() { return !portraitBlocked; }

  /* =================== JUEGO (tu lógica intacta) =================== */
  const BRAND = {
    GAME_NAME: '¿Te atreves?',
    CHAR_URLS: ['assets/char1.png','assets/char2.png','assets/char3.png','assets/char4.png'],
    COVER_IMAGE_URL: 'assets/cover.png',
    WIN_IMAGE_URL:   'assets/win.png',
    DEATH_SCENE: { text: 'Nos debes un cubata', img: 'assets/death.png' },
    COVER_EMOJI: '🕺',
    WIN_MESSAGE_BASE: '¡Lo has petado! Nivel completado 🎉',
    FINAL_OPTIONS: { a: 'Has ganado un chupito, paga Nete 🍹', b: 'Dale un beso a uno de los 4 😘' },
    ENABLE_FINAL_MODE: true
  };

  const SETTINGS = {
    CHAR_W: 96, CHAR_H: 96,
    G: 2550, JUMP_V: -1220,
    GROUND_Y: 608, PX_PER_M: 32,
    MAX_AIR_JUMPS: 1,
    LEVEL_LEN: 2000, BASE_SPEED: 7.0, END_SPEED: 15.5, ACCEL_EASE: 1.6,
    BPM_Q1: 96, BPM_Q2: 114, BPM_Q3: 132, BPM_Q4: 150,
    COYOTE: 0.16, JUMP_BUFFER: 0.16,
    TRAIL_SIZE: 32, TRAIL_INTERVAL: 0.034,
    SHAKE_MAX: 8, SHAKE_DECAY: 3.6,
    FWAVE: { spawnEvery: 0.60, power: 320, count: 55 },
    CONFETTI: { rate: 36, sizeMin: 6, sizeMax: 14 },
    FINAL_LEN: 800, FINAL_BPM: 164, FINAL_BASE_SPEED: 11.0, FINAL_END_SPEED: 16.5
  };

  const STATE = { MENU:0, PICK:1, PLAY:2, DEAD:3, WIN:4, FINAL:5, FINAL_WIN:6 };
  const clamp=(v,a,b)=>v<a?a:v>b?b:v; const lerp=(a,b,t)=>a+(b-a)*t; const easeOutPow=(t,p)=>1-Math.pow(1-t,p); const rand=(a,b)=>Math.random()*(b-a)+a; const rndInt=(a,b)=> (Math.random()*(b-a+1)+a)|0;

  const overlay = document.getElementById('overlay'); const overlayCard = document.getElementById('overlayCard'); const progressBar=document.getElementById('progressBar'); const statsEl=document.getElementById('stats'); const statusTag=document.getElementById('statusTag');

  const LS_REC='dd_record_landscape_only', LS_WINS='dd_wins_landscape_only';
  let recordDistance=parseFloat(localStorage.getItem(LS_REC)||'0'); let wins=parseInt(localStorage.getItem(LS_WINS)||'0',10);

  // Assets
  const charImgs = BRAND.CHAR_URLS.map(u=>{ const im=new Image(); im.decoding='async'; im.loading='eager'; im.src=u; return im; });
  const charReady = [false,false,false,false]; charImgs.forEach((im,i)=>{ im.onload=()=>charReady[i]=true; });

  // Mundo
  const W=BASE_W, H=BASE_H, groundY=SETTINGS.GROUND_Y;
  const player = { x: 260, y: groundY-SETTINGS.CHAR_H, w:SETTINGS.CHAR_W, h:SETTINGS.CHAR_H, vy:0, rotation:0, airborne:false };
  let chosenChar = 0, airJumpsUsed = 0;

  // Trail / Obs / Partículas
  const TRAIL_MAX=SETTINGS.TRAIL_SIZE|0; const trail=new Array(TRAIL_MAX).fill(0).map(()=>({x:0,y:0,a:0,r:0})); let trailIdx=0, trailTimer=0;
  const OBS_MAX=260; const obs=new Array(OBS_MAX).fill(0).map(()=>({active:false,type:'glass',x:0,y:0,w:0,h:0,baseY:0,t:0,amp:0}));
  const FW_MAX=600, CF_MAX=260; const fw=new Array(FW_MAX).fill(0).map(()=>({a:0,x:0,y:0,vx:0,vy:0,life:0,hue:0,sz:0})); const cf=new Array(CF_MAX).fill(0).map(()=>({a:0,x:0,y:0,vy:0,vx:0,rot:0,rvel:0,w:0,h:0,hue:0}));

  let state=STATE.MENU, isFinal=false; let distanceM=0, speedMS=SETTINGS.BASE_SPEED, progress=0, shakeT=0; let lastTime=performance.now();

  let beatDur=60/SETTINGS.BPM_Q1; const TOK = { S:'S', D:'D', G:'G', B:'B', P:'P', M:'M', V:'V', X:'X', GAP:'_' };
  const PATTERNS = {
    Q1: [ ['_','S','_','X'], ['G','_','_','_'], ['_','B','_','_'], ['_','X','_','S'], ['P','_','_','_'] ],
    Q2: [ ['S','_','S','_'], ['D','_','_','X'], ['B','_','_','S'], ['P','_','S','_'], ['M','_','_','X'] ],
    Q3: [ ['D','_','S','_'], ['G','_','S','_'], ['P','_','S','_'], ['M','_','_','S'], ['V','_','_','X'] ],
    Q4: [ ['S','_','S','X'], ['D','_','M','_'], ['B','_','D','_'], ['P','_','S','_'], ['M','_','S','_'] ]
  };
  function bpmForProgress(p){ if(isFinal) return SETTINGS.FINAL_BPM; if(p<.25) return SETTINGS.BPM_Q1; if(p<.5) return SETTINGS.BPM_Q2; if(p<.75) return SETTINGS.BPM_Q3; return SETTINGS.BPM_Q4; }
  function pickPattern(p){ const q=p<.25?'Q1':p<.5?'Q2':p<.75?'Q3':'Q4'; const list=PATTERNS[q]; return list[rndInt(0,list.length-1)].slice(); }
  let tokenQueue=[]; let beatTimer=0;

  // Entradas (SOLO sobre canvas; en vertical, se ignora)
  let keyJump=false, keyR=false, keyJumpHeld=false, coyoteT=0, bufferT=0;
  const onJumpPress=()=>{ if(!playingAllowed()) return; keyJump=true; keyJumpHeld=true; bufferT=SETTINGS.JUMP_BUFFER; };
  const onJumpRelease=()=>{ keyJumpHeld=false; };

  window.addEventListener('keydown',e=>{ if(!playingAllowed()) return;
    if(e.code==='Space'||e.code==='ArrowUp'){ e.preventDefault(); onJumpPress(); }
    else if(e.code==='KeyR'){ e.preventDefault(); keyR=true; }
  },{passive:false});
  window.addEventListener('keyup',e=>{ if(e.code==='Space'||e.code==='ArrowUp') onJumpRelease(); });

  canvas.addEventListener('pointerdown',(e)=>{ if(!playingAllowed()) return; e.preventDefault(); onJumpPress(); },{passive:false});
  window.addEventListener('pointerup',()=>{ onJumpRelease(); },{passive:true});
  window.addEventListener('pointercancel',()=>{ onJumpRelease(); },{passive:true});

  /* ===== Overlays ===== */
  const overlay = document.getElementById('overlay'); const overlayCard = document.getElementById('overlayCard'); const progressBar=document.getElementById('progressBar'); const statsEl=document.getElementById('stats'); const statusTag=document.getElementById('statusTag');
  function showOverlay(html){ overlayCard.innerHTML=html; overlay.style.display=''; }
  function hideOverlay(){ overlay.style.display='none'; }

  function showMenu(){
    const cover = BRAND.COVER_IMAGE_URL ? `<img class="cover" src="${BRAND.COVER_IMAGE_URL}" alt="Portada" />` : '';
    showOverlay(`
      <div>
        ${cover}
        <div class="emoji">${BRAND.COVER_EMOJI}</div>
        <div class="title" style="color:#d6cbff;text-shadow:0 0 28px rgba(139,92,246,.5)">${BRAND.GAME_NAME}</div>
        <div class="subtitle">Toca para <b>JUGAR</b>. (Horizontal) · <b>tap = salto</b>, <b>doble tap = doble salto</b>. <b>R</b> reinicia.</div>
        <div class="btns"><button class="btn" id="btnPlay">JUGAR</button></div>
      </div>`);
    document.getElementById('btnPlay').onclick=()=> showPick();
  }

  function showPick(){
    const grid = BRAND.CHAR_URLS.map((u,i)=>`<div class="char" data-i="${i}"><img src="${u}" alt="personaje ${i+1}"></div>`).join('');
    showOverlay(`
      <div>
        <div class="title">Elige tu personaje</div>
        <div class="chars" id="chars">${grid}</div>
        <div class="subtitle">Doble salto y tiempo coyote activos.</div>
        <div class="btns"><button class="btn" id="btnStart" disabled>Empezar</button></div>
      </div>`);
    statusTag.textContent='SELECCIÓN';
    const chars=document.querySelectorAll('.char'); let sel=-1; chars.forEach(el=>{
      el.onclick=()=>{ chars.forEach(c=>c.classList.remove('sel')); el.classList.add('sel'); sel=parseInt(el.dataset.i,10); chosenChar=sel; document.getElementById('btnStart').disabled=false; };
    });
    document.getElementById('btnStart').onclick=()=>{ hideOverlay(); state=STATE.PLAY; statusTag.textContent='JUGANDO'; };
  }

  function showDeath(){
    const dist=Math.floor(distanceM); const newRec=dist>recordDistance; if(newRec){ recordDistance=dist; localStorage.setItem(LS_REC,String(recordDistance)); }
    const sc = BRAND.DEATH_SCENE;
    const img = sc.img ? `<img class="death-photo" src="${sc.img}" alt="Derrota">` : '';
    showOverlay(`
      <div>
        ${img}
        <div class="big" style="color:var(--danger)">¡Has chocado!</div>
        <div class="subtitle" style="margin-bottom:8px">${sc.text}</div>
        <div class="btns"><button class="btn" id="btnRestart">Volver a intentar</button></div>
      </div>`);
    document.getElementById('btnRestart').onclick=()=>{ doRestart(); };
  }

  function showWin(){
    wins+=1; localStorage.setItem(LS_WINS,String(wins));
    const img = BRAND.WIN_IMAGE_URL ? `<img class="victory-photo" src="${BRAND.WIN_IMAGE_URL}" alt="Victoria">` : '';
    showOverlay(`
      <div>
        ${img}
        <canvas id="coin" width="240" height="240" style="display:block;margin:0 auto 8px;">Moneda</canvas>
        <div class="big" style="color:var(--gold)">${BRAND.WIN_MESSAGE_BASE}</div>
        <div class="btns">
          <button class="btn" id="btnAgain">Volver a jugar</button>
          ${BRAND.ENABLE_FINAL_MODE?'<button class="btn" id="btnFinal">Juego Final</button>':''}
        </div>
        <div class="btns" style="margin-top:6px">
          <button class="btn" id="optA">${BRAND.FINAL_OPTIONS.a}</button>
          <button class="btn" id="optB">${BRAND.FINAL_OPTIONS.b}</button>
        </div>
      </div>`);
    drawCoin(document.getElementById('coin'));
    document.getElementById('btnAgain').onclick=()=>doRestart();
    if(BRAND.ENABLE_FINAL_MODE) document.getElementById('btnFinal').onclick=()=>startFinal();
  }

  function showFinalWin(){
    wins+=1; localStorage.setItem(LS_WINS,String(wins));
    showOverlay(`
      <div>
        <div class="big" style="color:var(--gold)">🏆 ¡Dominaste la pista!</div>
        <div class="btns">
          <button class="btn" id="btnPlayBase">Nivel base</button>
          <button class="btn" id="btnPlayFinal">Repetir Final</button>
        </div>
      </div>`);
    document.getElementById('btnPlayBase').onclick=()=>doRestart();
    document.getElementById('btnPlayFinal').onclick=()=>startFinal();
  }

  function doRestart(){ hideOverlay(); reset(true); }
  function startFinal(){ resetFinal(); }

  function drawCoin(canvasEl){
    const c=canvasEl.getContext('2d'); const Wc=canvasEl.width, Hc=canvasEl.height; let t=0; let face = rndInt(0,3);
    const render=()=>{ const dt=1/60; t+=dt; c.clearRect(0,0,Wc,Hc); c.save(); c.translate(Wc/2,Hc/2); const flip=Math.abs(Math.cos(t*4)); const sx=lerp(.15,1,flip); c.scale(sx,1);
      const r=100; const grad=c.createRadialGradient(0,0,10,0,0,r); grad.addColorStop(0,'#fff1'); grad.addColorStop(1,'#f6c55a'); c.fillStyle=grad; c.beginPath(); c.arc(0,0,r,0,Math.PI*2); c.fill(); c.lineWidth=6; c.strokeStyle='rgba(0,0,0,.25)'; c.stroke();
      c.save(); c.beginPath(); c.arc(0,0,r-16,0,Math.PI*2); c.clip(); const im=charImgs[face]; if(charReady[face]) c.drawImage(im,-r,-r,2*r,2*r); else { c.fillStyle='#fff2'; c.fillRect(-r,-r,2*r,2*r); } c.restore(); c.restore(); requestAnimationFrame(render); };
    canvasEl.addEventListener('click',()=>{ t+=.8; });
    render();
  }

  // Spawner / obstáculos
  function nextToken(p){ if(tokenQueue.length===0){ tokenQueue = pickPattern(p); } return tokenQueue.shift(); }
  function spawnFromToken(tok){ const gx=W+20, gy=groundY; switch(tok){
    case 'S': makeGlass(gx, gy, 56, 92); break; case 'D': makeGlass(gx, gy, 56, 92); makeGlass(gx+120, gy, 56, 96); break;
    case 'G': makeHighGlass(gx, gy); break; case 'B': makeBottle(gx, gy); break; case 'P': makePerson(gx, gy); break;
    case 'M': makeSpeakerWave(gx, gy); break; case 'V': makeRope(gx, gy); break; case 'X': makeBox(gx, gy); break;
  }}
  function allocObs(){ for(let i=0;i<OBS_MAX;i++) if(!obs[i].active) return obs[i]; return obs[0]; }
  function makeGlass(x,gy,w=56,h=92){ const o=allocObs(); o.type='glass'; o.active=true; o.x=x; o.w=w; o.h=h; o.y=gy-o.h; o.baseY=o.y; }
  function makeHighGlass(x,gy){ makeGlass(x,gy,64,112); }
  function makeBottle(x,gy){ const o=allocObs(); o.type='bottle'; o.active=true; o.x=x; o.w=50; o.h=150; o.y=gy-o.h; o.baseY=o.y; }
  function makePerson(x,gy){ const o=allocObs(); o.type='person'; o.active=true; o.x=x; o.w=66; o.h=126; o.baseY=gy-o.h-28; o.y=o.baseY; o.amp=28; o.t=Math.random()*Math.PI*2; }
  function makeSpeakerWave(x,gy){ const o=allocObs(); o.type='music'; o.active=true; o.x=x; o.w=70; o.h=110; o.baseY=gy-o.h-40; o.y=o.baseY; o.amp=38; o.t=Math.random()*Math.PI*2; }
  function makeRope(x,gy){ const o=allocObs(); o.type='rope'; o.active=true; o.x=x; o.w=120; o.h=44; o.y=gy-o.h; }
  function makeBox(x,gy){ const o=allocObs(); o.type='box'; o.active=true; o.x=x; o.w=120; o.h=70; o.y=gy-o.h-26; o.baseY=o.y; }

  const aabb=(px,py,pw,ph,ox,oy,ow,oh)=> (px<ox+ow && px+pw>ox && py<oy+oh && py+ph>oy);

  // Dibujo
  function drawBackground(dt,camX){
    const t=performance.now()/1000; const c1=`hsl(${(t*40)%360} 80% 10%)`; const c2=`hsl(${(t*40+120)%360} 80% 8%)`; const c3=`hsl(${(t*40+240)%360} 80% 6%)`;
    const sky=ctx.createLinearGradient(0,0,0,H); sky.addColorStop(0,c1); sky.addColorStop(.5,c2); sky.addColorStop(1,c3); ctx.fillStyle=sky; ctx.fillRect(0,0,W,H);
    ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.globalAlpha=.25; for(let i=0;i<6;i++){ const y=(Math.sin(t*1.2+i)*.5+.5)*H*.6+H*.1; ctx.fillStyle=`hsl(${(i*60+t*120)%360} 100% 60% / .6)`; ctx.fillRect((i/6)*W, y, W/6, 6); } ctx.restore();
    const step=64; const scroll=(camX*.2)%step; ctx.save(); ctx.globalAlpha=.22; ctx.strokeStyle='rgba(214,203,255,.18)'; ctx.lineWidth=1; ctx.translate(-scroll,0);
    for(let x=0;x=W+step;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<H;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); } ctx.restore();
    const gy=groundY; const glow=ctx.createLinearGradient(0,gy-38,0,gy+12); glow.addColorStop(0,'rgba(139,92,246,.22)'); glow.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=glow; ctx.fillRect(0,gy-38,W,50); ctx.fillStyle='#0a0f1a'; ctx.fillRect(0,gy,W,H-gy); ctx.fillStyle='#131b2a'; ctx.fillRect(0,gy-12,W,12);
  }
  function roundRect(c,x,y,w,h,r){ const rr=Math.min(r,w/2,h/2); c.beginPath(); c.moveTo(x+rr,y); c.arcTo(x+w,y,x+w,y+h,rr); c.arcTo(x+w,y+h,x,y+h,rr); c.arcTo(x,y+h,x,y,rr); c.arcTo(x,y,x+w,y,rr); c.closePath(); }
  function drawObstacle(o){
    ctx.save(); ctx.shadowColor='rgba(0,0,0,.5)'; ctx.shadowBlur=18; let grad=ctx.createLinearGradient(o.x,o.y,o.x,o.y+o.h); grad.addColorStop(0,'#8b5cf6'); grad.addColorStop(1,'#00ffd5'); ctx.fillStyle=grad; ctx.strokeStyle='rgba(255,255,255,.15)';
    if(o.type==='glass'){ ctx.beginPath(); ctx.moveTo(o.x, o.y+o.h); ctx.lineTo(o.x+o.w/2, o.y); ctx.lineTo(o.x+o.w, o.y+o.h); ctx.closePath(); ctx.fill(); ctx.stroke();
    } else if(o.type==='bottle'){ const neckH=20; ctx.fillRect(o.x+o.w*.35, o.y-neckH, o.w*.3, neckH); ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeRect(o.x+.5, o.y+.5, o.w-1, o.h-1);
    } else if(o.type==='person'){ const r=o.w*.34; ctx.beginPath(); ctx.arc(o.x+o.w/2, o.y+r, r, 0, Math.PI*2); ctx.fill(); ctx.fillRect(o.x+o.w*.28, o.y+r*2, o.w*.44, o.h-r*2);
    } else if(o.type==='music'){ ctx.fillRect(o.x, o.y, o.w, o.h); for(let i=0;i<6;i++){ ctx.fillRect(o.x+i*10, o.y-10, 6, 10); }
    } else if(o.type==='rope'){ ctx.fillRect(o.x, o.y+o.h-12, o.w, 12); ctx.beginPath(); ctx.moveTo(o.x+12,o.y+o.h-12); ctx.lineTo(o.x+12,o.y); ctx.moveTo(o.x+o.w-12,o.y+o.h-12); ctx.lineTo(o.x+o.w-12,o.y); ctx.lineWidth=6; ctx.strokeStyle='rgba(255,255,255,.25)'; ctx.stroke();
    } else if(o.type==='box'){ const r=12; roundRect(ctx, o.x, o.y, o.w, o.h, r); ctx.fill(); ctx.stroke(); } else { ctx.fillRect(o.x, o.y, o.w, o.h); }
    ctx.restore();
  }
  function drawPlayer(dt){
    for(let i=0;i<TRAIL_MAX;i++){ const p=trail[i]; if(p.a<=0) continue; p.a-=dt*1.8; if(p.a<0) p.a=0; ctx.save(); ctx.globalAlpha=p.a*.7; const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r); g.addColorStop(0,'rgba(214,203,255,.9)'); g.addColorStop(1,'rgba(139,92,246,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); ctx.restore(); }
    ctx.save(); ctx.translate(player.x+player.w/2, player.y+player.h/2); ctx.rotate(player.rotation); ctx.shadowColor='rgba(139,92,246,.85)'; ctx.shadowBlur= player.airborne ? 34 : 18; const im=charImgs[chosenChar]; if(charReady[chosenChar]) ctx.drawImage(im,-player.w/2,-player.h/2,player.w,player.h); else { ctx.fillStyle='#d6cbff'; roundRect(ctx,-player.w/2,-player.h/2,player.w,player.h,14); ctx.fill(); } ctx.shadowBlur=0; ctx.restore();
  }
  function drawVictoryEffects(dt){
    for(let i=0;i<FW_MAX;i++){ const p=fw[i]; if(p.a<=0) continue; p.life-=dt; p.a=clamp(p.life,0,1); p.vy+=80*dt; p.x+=p.vx*dt; p.y+=p.vy*dt; ctx.save(); ctx.globalAlpha=p.a; ctx.fillStyle=`hsl(${p.hue} 100% 60%)`; ctx.beginPath(); ctx.arc(p.x,p.y,p.sz,0,Math.PI*2); ctx.fill(); ctx.restore(); }
    for(let i=0;i<CF_MAX;i++){ const c=cf[i]; if(c.a<=0) continue; c.vy+=30*dt; c.x+=c.vx*dt; c.y+=c.vy*dt; c.rot+=c.rvel*dt; if(c.y>H+20){ c.a=0; continue; } ctx.save(); ctx.globalAlpha=.9; ctx.translate(c.x,c.y); ctx.rotate(c.rot); ctx.fillStyle=`hsl(${c.hue} 100% 60%)`; ctx.fillRect(-c.w/2,-c.h/2,c.w,c.h); ctx.restore(); }
  }

  // Loop
  let fwTimer=0;
  function loop(ts){
    const dt=Math.min(1/20,(ts-lastTime)/1000); lastTime=ts;
    const wantR=keyR; keyR=false;

    if(playingAllowed()){
      if(state===STATE.MENU){ if(keyJump) showPick(); keyJump=false; }
      if(state===STATE.PICK){ /* overlay maneja */ }
      if(state===STATE.PLAY||state===STATE.FINAL){ update(dt); keyJump=false; }
      if(state===STATE.DEAD){ if(wantR) doRestart(); }
      if(state===STATE.WIN||state===STATE.FINAL_WIN){
        fwTimer-=dt; if(fwTimer<=0){ spawnFirework(); fwTimer=SETTINGS.FWAVE.spawnEvery; }
        spawnConfetti(dt);
        if(keyJump){ doRestart(); }
        keyJump=false;
      }
    }

    const shake=(shakeT>0)?SETTINGS.SHAKE_MAX*(shakeT):0; if(shakeT>0) shakeT=Math.max(0, SETTINGS.SHAKE_DECAY? shakeT-SETTINGS.SHAKE_DECAY*dt : 0);
    ctx.save(); if(shake>0) ctx.translate(rand(-shake,shake), rand(-shake,shake));
    drawBackground(dt, distanceM*SETTINGS.PX_PER_M);
    for(let i=0;i<OBS_MAX;i++) if(obs[i].active) drawObstacle(obs[i]);
    drawPlayer(dt); if(state===STATE.WIN||state===STATE.FINAL_WIN) drawVictoryEffects(dt);
    ctx.restore(); updateHUD(); requestAnimationFrame(loop);
  }

  function attemptJump(){
    if(coyoteT>0 || !player.airborne){ jump(); airJumpsUsed = 0; return true; }
    if(airJumpsUsed < SETTINGS.MAX_AIR_JUMPS){ jump(true); airJumpsUsed++; return true; }
    return false;
  }
  function update(dt){
    const len=isFinal?SETTINGS.FINAL_LEN:SETTINGS.LEVEL_LEN; const base=isFinal?SETTINGS.FINAL_BASE_SPEED:SETTINGS.BASE_SPEED; const end=isFinal?SETTINGS.FINAL_END_SPEED:SETTINGS.END_SPEED;
    progress=clamp(distanceM/len,0,1); speedMS=lerp(base,end,easeOutPow(progress,SETTINGS.ACCEL_EASE)); distanceM+=speedMS*dt;

    const targetBPM=bpmForProgress(progress); beatDur=60/targetBPM; beatTimer-=dt; if(beatTimer<=0){ const tok=nextToken(progress)||'_'; spawnFromToken(tok); beatTimer+=beatDur; }

    const prevY = player.y;
    if(bufferT>0){ if(attemptJump()) bufferT=0; else bufferT-=dt; } else { bufferT-=dt; }

    if(player.airborne) coyoteT = Math.max(0, coyoteT - dt); else coyoteT = SETTINGS.COYOTE;
    player.vy += SETTINGS.G*dt; player.y += player.vy*dt; const gy=groundY-player.h; if(player.y>=gy){ player.y=gy; player.vy=0; if(player.airborne){ coyoteT=SETTINGS.COYOTE; } player.airborne=false; airJumpsUsed=0; } else player.airborne=true;

    if(player.airborne){ player.rotation += clamp(player.vy/900,-1.2,1.2)*dt*2.1; player.rotation = clamp(player.rotation,-0.6,0.6); } else { player.rotation *= Math.pow(0.001, dt); }

    const dx=speedMS*dt*SETTINGS.PX_PER_M; for(let i=0;i<OBS_MAX;i++){ const o=obs[i]; if(!o.active) continue; o.x-=dx; if(o.type==='person' || o.type==='music'){ o.t+=dt*2; o.y = o.baseY + Math.sin(o.t) * o.amp; } if(o.x+o.w<-40) o.active=false; }

    trailTimer -= dt; if(trailTimer<=0){ const p=trail[trailIdx++%TRAIL_MAX]; p.x=player.x+player.w/2; p.y=player.y+player.h/2; p.a=1; p.r=rand(10,22); trailTimer=SETTINGS.TRAIL_INTERVAL; }

    const px=player.x, py=player.y, pw=player.w, ph=player.h; for(let i=0;i<OBS_MAX;i++){
      const o=obs[i]; if(!o.active) continue; if(!aabb(px,py,pw,ph,o.x,o.y,o.w,o.h)) continue;
      if(o.type==='box'){
        const tolerance = 10;
        if(prevY + ph <= o.y + tolerance && player.vy >= 0){ player.y = o.y - ph; player.vy = 0; player.airborne = false; airJumpsUsed=0; }
        else { state=STATE.DEAD; statusTag.textContent='DERROTA'; shakeT=1.0; showDeath(); break; }
      } else {
        state=STATE.DEAD; statusTag.textContent='DERROTA'; shakeT=1.0; showDeath(); break;
      }
    }

    if(progress>=1){ if(!isFinal){ state=STATE.WIN; statusTag.textContent='VICTORIA'; showWin(); } else { state=STATE.FINAL_WIN; statusTag.textContent='VICTORIA'; showFinalWin(); } }
  }
  function jump(isAir=false){ player.vy=SETTINGS.JUMP_V; player.airborne=true; if(isAir){ shakeT=Math.max(shakeT,.18); } }
  function updateHUD(){ const pct=Math.floor(progress*100); progressBar.style.width=pct+'%'; const dist=Math.floor(distanceM); const rec=Math.floor(Math.max(recordDistance,dist)); statsEl.innerHTML = `Distancia: <b>${dist} m</b> · Récord: <b>${rec} m</b> · Ganadas: <b>${wins}</b> · <b>Doble salto</b>`; }

  function showWinSafe(){ try{ showWin(); }catch{} }
  function tinyShake(){ shakeT = Math.max(shakeT, .3); }

  function reset(toMenu=true){ state=toMenu?STATE.MENU:STATE.PLAY; isFinal=false; distanceM=0; speedMS=SETTINGS.BASE_SPEED; progress=0; shakeT=0; tokenQueue.length=0; beatDur=60/bpmForProgress(0); beatTimer=beatDur; coyoteT=0; bufferT=0; airJumpsUsed=0; player.x=260; player.y=groundY-SETTINGS.CHAR_H; player.w=SETTINGS.CHAR_W; player.h=SETTINGS.CHAR_H; player.vy=0; player.rotation=0; player.airborne=false; trail.forEach(p=>p.a=0); obs.forEach(o=>o.active=false); fw.forEach(p=>p.a=0); cf.forEach(c=>c.a=0); statusTag.textContent='MENÚ'; showMenu(); }
  function resetFinal(){ state=STATE.FINAL; isFinal=true; distanceM=0; progress=0; tokenQueue.length=0; beatDur=60/SETTINGS.FINAL_BPM; beatTimer=beatDur; speedMS=SETTINGS.FINAL_BASE_SPEED; airJumpsUsed=0; obs.forEach(o=>o.active=false); hideOverlay(); statusTag.textContent='FINAL'; }

  /* ====== Inicialización / listeners ====== */
  function handleResize(){ fit(); }
  fit();
  window.addEventListener('resize', handleResize);
  (window.visualViewport||window).addEventListener?.('resize', handleResize);
  window.addEventListener('orientationchange', ()=>{ setTimeout(handleResize, 250); });

  reset(true); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
