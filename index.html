<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>¿Te atreves? – Disco Dash</title>
<style>
  :root {
    --ui-bg: rgba(0,0,0,0.42); --ui-text:#fff; --accent:#8b5cf6; --accent2:#00ffd5; --danger:#ff4d6d; --gold:#ffd166;
    --pad-top: env(safe-area-inset-top, 0px);
    --pad-right: env(safe-area-inset-right, 0px);
    --pad-bottom: env(safe-area-inset-bottom, 0px);
    --pad-left: env(safe-area-inset-left, 0px);
  }
  html, body { height:100%; margin:0; background:#05060c; color:var(--ui-text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, "Noto Sans", sans-serif; overflow:hidden; }
  .root { width:100vw; height:100dvh; display:grid; place-items:center; padding: var(--pad-top) var(--pad-right) var(--pad-bottom) var(--pad-left); box-sizing:border-box; }
  .game-wrap { position:relative; width:100%; height:100%; display:grid; place-items:center; }
  /* El contenedor .stage ajusta su aspecto según orientación por JS; aquí solo estilos comunes */
  .stage { width:100%; height:100%; border-radius:16px; overflow:hidden; box-shadow:0 20px 60px rgba(0,0,0,.65), inset 0 0 0 1px rgba(255,255,255,.06); position:relative; }
  canvas { width:100%; height:100%; display:block; background:transparent; touch-action:none; }

  /* HUD */
  .hud { position:absolute; left:12px; right:12px; top:10px; display:grid; grid-template-columns:1fr auto; gap:12px; pointer-events:none; }
  .panel { background:var(--ui-bg); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:8px 12px; box-shadow: 0 8px 24px rgba(0,0,0,.35); }
  .progress { height:10px; border-radius:6px; overflow:hidden; position:relative; box-shadow: inset 0 0 0 1px rgba(255,255,255,.06); background: linear-gradient(90deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); }
  .progress > .bar { height:100%; width:0%; background: linear-gradient(90deg, #8b5cf6, #00ffd5 40%, #9bffd4 60%, #fffcc0 100%); box-shadow:0 0 18px #8b5cf6; }
  .stats { font-size:14px; line-height:1.2; }
  .stats b { color:#d6cbff; }
  .status-tag { padding:4px 10px; border-radius:10px; font-weight:800; letter-spacing:.5px; font-size:12px; background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.15)); border:1px solid rgba(255,255,255,.08); }

  /* Overlays */
  .overlay { position:absolute; inset:0; display:grid; place-items:center; text-align:center; padding:24px; pointer-events:none; }
  .overlay .card { pointer-events:auto; padding:18px 22px; border-radius:14px; background: linear-gradient(180deg, rgba(0,0,0,.58), rgba(0,0,0,.32)); border:1px solid rgba(255,255,255,.08); box-shadow:0 24px 64px rgba(0,0,0,.55); max-width:min(92%, 1100px); }
  .title { font-size:clamp(22px, 3.8vw, 44px); margin:8px 0 6px; font-weight:900; letter-spacing:.3px; }
  .subtitle { font-size:clamp(14px, 2vw, 18px); opacity:.9; }
  .big { font-size:clamp(22px, 4vw, 54px); font-weight:900; text-shadow:0 6px 30px rgba(0,0,0,.6); }
  .btns { display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:14px; }
  .btn { cursor:pointer; background: linear-gradient(180deg, #1e293b, #0b1220); color:#dff9ff; border:1px solid rgba(255,255,255,.1); padding:12px 16px; border-radius:12px; font-weight:800; letter-spacing:.3px; box-shadow:0 10px 24px rgba(0,0,0,.4); transition: transform .06s ease, filter .15s ease; font-size:16px; }
  .btn:hover { filter:brightness(1.1); }
  .btn:active { transform: translateY(1px) scale(.995); }
  .btn[disabled] { opacity:.6; cursor: not-allowed; }

  /* Selección de personaje */
  .chars { display:grid; grid-template-columns: repeat(4, minmax(100px, 1fr)); gap:12px; margin-top:12px; }
  .char { background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.1); border-radius:12px; padding:6px; position:relative; }
  .char img { width:100%; height:120px; object-fit:cover; border-radius:10px; display:block; }
  .char:hover { outline:2px solid rgba(139,92,246,.45); }
  .char.sel { outline:3px solid #8b5cf6; box-shadow:0 0 24px rgba(139,92,246,.35) inset; }

  .emoji { display:inline-block; font-size: clamp(28px, 6vw, 72px); filter: drop-shadow(0 8px 24px rgba(139,92,246,.6)); animation: bob 1.6s ease-in-out infinite; }
  @keyframes bob { 0%,100%{ transform: translateY(0); } 50%{ transform: translateY(-8px) rotate(-2deg);} }

  .cover { display:block; width:min(86vw, 780px); max-height:48vh; object-fit:cover; border-radius:12px; box-shadow: 0 14px 40px rgba(0,0,0,.5); border:1px solid rgba(255,255,255,.08); margin: 0 auto 8px; }
  .victory-photo, .death-photo { display:block; width:min(86vw, 560px); max-height:40vh; object-fit:cover; border-radius:10px; margin: 8px auto 8px; box-shadow: 0 12px 32px rgba(0,0,0,.5); border:1px solid rgba(255,255,255,.08); }

  .rotate-hint { position:absolute; inset:auto auto 10px 10px; background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:6px 10px; font-size:12px; display:none; pointer-events:none; }
  .rotate-hint.show { display:block; }
</style>
</head>
<body>
<div class="root">
  <div class="game-wrap" aria-live="polite">
    <div class="stage" id="stage">
      <canvas id="game" width="1280" height="720" aria-label="¿Te atreves? Juego rítmico de discoteca. Controles: toca para saltar (doble salto). R reinicia."></canvas>

      <!-- HUD -->
      <div class="hud" aria-hidden="true">
        <div class="panel">
          <div class="progress" title="Progreso nivel">
            <div class="bar" id="progressBar"></div>
          </div>
          <div class="stats" id="stats"></div>
        </div>
        <div class="status-tag" id="statusTag">MENÚ</div>
      </div>

      <!-- Overlays -->
      <div class="overlay" id="overlay" style="display:none">
        <div class="card" id="overlayCard"></div>
      </div>

      <div class="rotate-hint" id="rotateHint">📱 Juega también en vertical</div>
    </div>
  </div>
</div>

<script>
(() => {
  'use strict';

  /* =================== ASSETS / MARCA =================== */
  const BRAND = {
    GAME_NAME: '¿Te atreves?',
    CHAR_URLS: ['assets/char1.png','assets/char2.png','assets/char3.png','assets/char4.png'],
    COVER_IMAGE_URL: 'assets/cover.png',
    WIN_IMAGE_URL:   'assets/win.png',
    DEATH_SCENE: { text: 'Nos debes un cubata', img: 'assets/death.png' },
    COVER_EMOJI: '🕺',
    WIN_MESSAGE_BASE: '¡Lo has petado! Nivel completado 🎉',
    FINAL_OPTIONS: { a: 'Has ganado un chupito, paga Nete 🍹', b: 'Dale un beso a uno de los 4 😘' },
    ENABLE_FINAL_MODE: true
  };

  /* ================= PARÁMETROS BASE ================= */
  const SETTINGS = {
    // Estos son valores base de diseño 1280x720 (se escalan con K)
    CHAR_W_BASE: 96, CHAR_H_BASE: 96,
    G_BASE: 2550, JUMP_V_BASE: -1220,
    GROUND_MARGIN_BASE: 112,    // 720 - 608 = 112  → suelo = H - 112*K
    PX_PER_M_BASE: 32,

    // Doble salto
    MAX_AIR_JUMPS: 1,

    // Nivel
    LEVEL_LEN: 2000, BASE_SPEED: 7.0, END_SPEED: 15.5, ACCEL_EASE: 1.6,

    // BPM por tramos
    BPM_Q1: 96, BPM_Q2: 114, BPM_Q3: 132, BPM_Q4: 150,

    // Control
    COYOTE: 0.16, JUMP_BUFFER: 0.16,

    // Efectos
    TRAIL_SIZE: 32, TRAIL_INTERVAL: 0.034,
    SHAKE_MAX: 8, SHAKE_DECAY: 3.6,

    // Victoria
    FWAVE: { spawnEvery: 0.60, power: 320, count: 55 },
    CONFETTI: { rate: 36, sizeMin: 6, sizeMax: 14 },

    // Final
    FINAL_LEN: 800, FINAL_BPM: 164, FINAL_BASE_SPEED: 11.0, FINAL_END_SPEED: 16.5
  };

  const STATE = { MENU:0, PICK:1, PLAY:2, DEAD:3, WIN:4, FINAL:5, FINAL_WIN:6 };
  const clamp=(v,a,b)=>v<a?a:v>b?b:v; const lerp=(a,b,t)=>a+(b-a)*t; const easeOutPow=(t,p)=>1-Math.pow(1-t,p); const rand=(a,b)=>Math.random()*(b-a)+a; const rndInt=(a,b)=> (Math.random()*(b-a+1)+a)|0;

  // Canvas / viewport
  const stageEl = document.getElementById('stage');
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });

  // Mundo lógico dinámico
  let W = 1280, H = 720;    // se actualiza según orientación
  let K = 1;                // factor de escala respecto a base 720p
  let DPR = 1;

  // Variables dependientes de K
  let PX_PER_M = SETTINGS.PX_PER_M_BASE;
  let G = SETTINGS.G_BASE, JUMP_V = SETTINGS.JUMP_V_BASE;
  let groundY = 608;        // recalculado
  let CHAR_W = SETTINGS.CHAR_W_BASE, CHAR_H = SETTINGS.CHAR_H_BASE;

  function applyScaleDerived() {
    PX_PER_M = SETTINGS.PX_PER_M_BASE * K;
    G       = SETTINGS.G_BASE * K;
    JUMP_V  = SETTINGS.JUMP_V_BASE * Math.sqrt(K); // ajusta salto para mantener “tiempo de aire”
    groundY = Math.round(H - SETTINGS.GROUND_MARGIN_BASE * K);
    CHAR_W  = Math.round(SETTINGS.CHAR_W_BASE * K);
    CHAR_H  = Math.round(SETTINGS.CHAR_H_BASE * K);
    player.w = CHAR_W; player.h = CHAR_H;
    // Reposiciona al jugador sobre el “suelo” actualizado
    if (!player.airborne) player.y = groundY - player.h;
  }

  function fitCanvas() {
    const vp = window.visualViewport || { width: window.innerWidth, height: window.innerHeight };
    const availW = Math.min(window.innerWidth, vp.width);
    const availH = Math.min(window.innerHeight, vp.height);

    const isPortrait = availH > availW;

    // Mundo lógico según orientación:
    if (isPortrait) { W = 720; H = 1280; }
    else { W = 1280; H = 720; }

    // CSS size: encajar contenedor .stage al máximo manteniendo aspecto del mundo
    const targetAspect = W / H;
    let cssW = availW, cssH = availW / targetAspect;
    if (cssH > availH) { cssH = availH; cssW = cssH * targetAspect; }

    stageEl.style.width  = cssW + 'px';
    stageEl.style.height = cssH + 'px';

    // DPR para nitidez
    DPR = Math.min(window.devicePixelRatio || 1, 3);
    canvas.width  = Math.round(W * DPR);
    canvas.height = Math.round(H * DPR);
    canvas.style.width  = '100%';
    canvas.style.height = '100%';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

    // Factor de escala K relativo a 720p de altura base
    K = H / 720;
    applyScaleDerived();

    // Hint no bloquea nada y solo en casos “estrechos”
    const rotateHint = document.getElementById('rotateHint');
    rotateHint.classList.toggle('show', isPortrait && availW < 420);
  }

  // Evita zoom por doble-tap en iOS
  let lastTouchEnd = 0;
  document.addEventListener('touchend', function (e) {
    const now = Date.now();
    if (now - lastTouchEnd <= 350) e.preventDefault();
    lastTouchEnd = now;
  }, { passive:false });

  // UI
  const overlay = document.getElementById('overlay'); const overlayCard = document.getElementById('overlayCard'); const progressBar=document.getElementById('progressBar'); const statsEl=document.getElementById('stats'); const statusTag=document.getElementById('statusTag');

  // LocalStorage
  const LS_REC='dd_record_v6', LS_WINS='dd_wins_v6'; let recordDistance=parseFloat(localStorage.getItem(LS_REC)||'0'); let wins=parseInt(localStorage.getItem(LS_WINS)||'0',10);

  // Sprites
  const charImgs = BRAND.CHAR_URLS.map(u=>{ const im=new Image(); im.decoding='async'; im.loading='eager'; im.src=u; return im; });
  const charReady = [false,false,false,false]; charImgs.forEach((im,i)=>{ im.onload=()=>charReady[i]=true; });

  // Estado jugador / mundo
  const player = { x: 260, y: 0, w: 0, h: 0, vy:0, rotation:0, airborne:false };
  let chosenChar = 0;
  let airJumpsUsed = 0;

  // Trail
  const TRAIL_MAX=SETTINGS.TRAIL_SIZE|0; const trail=new Array(TRAIL_MAX); for(let i=0;i<TRAIL_MAX;i++) trail[i]={x:0,y:0,a:0,r:0}; let trailIdx=0, trailTimer=0;

  // Obstáculos
  const OBS_MAX=260; const obs=new Array(OBS_MAX); for(let i=0;i<OBS_MAX;i++) obs[i]={active:false,type:'glass',x:0,y:0,w:0,h:0,baseY:0,t:0,amp:0};

  // Partículas
  const FW_MAX=600, CF_MAX=260; const fw=new Array(FW_MAX); for(let i=0;i<FW_MAX;i++) fw[i]={a:0,x:0,y:0,vx:0,vy:0,life:0,hue:0,sz:0}; const cf=new Array(CF_MAX); for(let i=0;i<CF_MAX;i++) cf[i]={a:0,x:0,y:0,vy:0,vx:0,rot:0,rvel:0,w:0,h:0,hue:0};

  // Juego
  let state=STATE.MENU, isFinal=false; let distanceM=0, speedMS=SETTINGS.BASE_SPEED, progress=0, shakeT=0; let lastTime=performance.now();

  // Ritmo
  let beatDur=60/SETTINGS.BPM_Q1;
  const TOK = { S:'S', D:'D', G:'G', B:'B', P:'P', M:'M', V:'V', X:'X', GAP:'_' };
  const PATTERNS = {
    Q1: [ ['_','S','_','X'], ['G','_','_','_'], ['_','B','_','_'], ['_','X','_','S'], ['P','_','_','_'] ],
    Q2: [ ['S','_','S','_'], ['D','_','_','X'], ['B','_','_','S'], ['P','_','S','_'], ['M','_','_','X'] ],
    Q3: [ ['D','_','S','_'], ['G','_','S','_'], ['P','_','S','_'], ['M','_','_','S'], ['V','_','_','X'] ],
    Q4: [ ['S','_','S','X'], ['D','_','M','_'], ['B','_','D','_'], ['P','_','S','_'], ['M','_','S','_'] ]
  };
  function bpmForProgress(p){ if(isFinal) return SETTINGS.FINAL_BPM; if(p<.25) return SETTINGS.BPM_Q1; if(p<.5) return SETTINGS.BPM_Q2; if(p<.75) return SETTINGS.BPM_Q3; return SETTINGS.BPM_Q4; }
  function pickPattern(p){ const q=p<.25?'Q1':p<.5?'Q2':p<.75?'Q3':'Q4'; const list=PATTERNS[q]; return list[rndInt(0,list.length-1)].slice(); }
  let tokenQueue=[]; let beatTimer=0;

  // Entradas
  let keyJump=false, keyJumpHeld=false, keyR=false; let coyoteT=0, bufferT=0;
  const onJumpPress=()=>{ keyJump=true; keyJumpHeld=true; bufferT=SETTINGS.JUMP_BUFFER; };
  const onJumpRelease=()=>{ keyJumpHeld=false; };

  window.addEventListener('keydown',e=>{ if(e.code==='Space'||e.code==='ArrowUp'){ e.preventDefault(); onJumpPress(); } else if(e.code==='KeyR'){ e.preventDefault(); keyR=true; } },{passive:false});
  window.addEventListener('keyup',e=>{ if(e.code==='Space'||e.code==='ArrowUp') onJumpRelease(); });

  canvas.addEventListener('pointerdown', (e)=>{ e.preventDefault(); onJumpPress(); }, {passive:false});
  window.addEventListener('pointerup', ()=>{ onJumpRelease(); }, {passive:true});
  window.addEventListener('pointercancel', ()=>{ onJumpRelease(); }, {passive:true});

  ['touchstart','touchmove'].forEach(evt=>{
    document.addEventListener(evt, (e)=>{
      if (e.target === canvas || stageEl.contains(e.target)) e.preventDefault();
    }, {passive:false});
  });

  function reset(toMenu=true){
    state=toMenu?STATE.MENU:STATE.PLAY; isFinal=false; distanceM=0; speedMS=SETTINGS.BASE_SPEED; progress=0; shakeT=0;
    tokenQueue.length=0; beatDur=60/bpmForProgress(0); beatTimer=beatDur; coyoteT=0; bufferT=0; airJumpsUsed=0;
    player.x=Math.round(260 * K); player.y=groundY-CHAR_H; player.w=CHAR_W; player.h=CHAR_H; player.vy=0; player.rotation=0; player.airborne=false;
    for(let i=0;i<TRAIL_MAX;i++) trail[i].a=0; for(let i=0;i<OBS_MAX;i++) obs[i].active=false; for(let i=0;i<FW_MAX;i++) fw[i].a=0; for(let i=0;i<CF_MAX;i++) cf[i].a=0;
    statusTag.textContent='MENÚ'; showMenu();
  }
  function resetFinal(){
    state=STATE.FINAL; isFinal=true; distanceM=0; progress=0; tokenQueue.length=0; beatDur=60/SETTINGS.FINAL_BPM; beatTimer=beatDur; speedMS=SETTINGS.FINAL_BASE_SPEED; airJumpsUsed=0;
    for(let i=0;i<OBS_MAX;i++) obs[i].active=false; hideOverlay(); statusTag.textContent='FINAL';
  }

  // ====== UI ======
  function showOverlay(html){ overlayCard.innerHTML=html; overlay.style.display=''; }
  function hideOverlay(){ overlay.style.display='none'; }

  function showMenu(){
    const cover = BRAND.COVER_IMAGE_URL ? `<img class="cover" src="${BRAND.COVER_IMAGE_URL}" alt="Portada" />` : '';
    showOverlay(`
      <div>
        ${cover}
        <div class="emoji">${BRAND.COVER_EMOJI}</div>
        <div class="title" style="color:#d6cbff; text-shadow:0 0 28px rgba(139,92,246,.5)">${BRAND.GAME_NAME}</div>
        <div class="subtitle">Toca para <b>JUGAR</b>. En partida: <b>tap = salto</b>, <b>doble tap = doble salto</b>. (Tecla <b>R</b> reinicia)</div>
        <div class="btns"><button class="btn" id="btnPlay">JUGAR</button></div>
      </div>`);
    document.getElementById('btnPlay').onclick=()=> showPick();
  }

  function showPick(){
    const grid = BRAND.CHAR_URLS.map((u,i)=>`<div class="char" data-i="${i}"><img src="${u}" alt="personaje ${i+1}"></div>`).join('');
    showOverlay(`
      <div>
        <div class="title">Elige tu personaje</div>
        <div class="chars" id="chars">${grid}</div>
        <div class="subtitle">Doble salto y tiempo coyote activos.</div>
        <div class="btns"><button class="btn" id="btnStart" disabled>Empezar</button></div>
      </div>`);
    statusTag.textContent='SELECCIÓN';
    const chars=document.querySelectorAll('.char'); let sel=-1; chars.forEach(el=>{
      el.onclick=()=>{ chars.forEach(c=>c.classList.remove('sel')); el.classList.add('sel'); sel=parseInt(el.dataset.i,10); chosenChar=sel; document.getElementById('btnStart').disabled=false; };
    });
    document.getElementById('btnStart').onclick=()=>{ hideOverlay(); state=STATE.PLAY; statusTag.textContent='JUGANDO'; };
  }

  function showDeath(){
    const dist=Math.floor(distanceM); const newRec=dist>recordDistance; if(newRec){ recordDistance=dist; localStorage.setItem(LS_REC,String(recordDistance)); }
    const sc = BRAND.DEATH_SCENE;
    const img = sc.img ? `<img class="death-photo" src="${sc.img}" alt="Derrota">` : '';
    showOverlay(`
      <div>
        ${img}
        <div class="big" style="color:var(--danger)">¡Has chocado!</div>
        <div class="subtitle" style="margin-bottom:8px">${sc.text}</div>
        <div class="btns"><button class="btn" id="btnRestart">Volver a intentar</button></div>
      </div>`);
    document.getElementById('btnRestart').onclick=()=>{ doRestart(); };
  }

  function showWin(){
    wins+=1; localStorage.setItem(LS_WINS,String(wins));
    const img = BRAND.WIN_IMAGE_URL ? `<img class="victory-photo" src="${BRAND.WIN_IMAGE_URL}" alt="Victoria">` : '';
    showOverlay(`
      <div>
        ${img}
        <canvas id="coin" width="240" height="240" style="display:block;margin:0 auto 8px;">Moneda</canvas>
        <div class="big" style="color:var(--gold)">${BRAND.WIN_MESSAGE_BASE}</div>
        <div class="btns">
          <button class="btn" id="btnAgain">Volver a jugar</button>
          ${BRAND.ENABLE_FINAL_MODE?'<button class="btn" id="btnFinal">Juego Final</button>':''}
        </div>
        <div class="btns" style="margin-top:6px">
          <button class="btn" id="optA">${BRAND.FINAL_OPTIONS.a}</button>
          <button class="btn" id="optB">${BRAND.FINAL_OPTIONS.b}</button>
        </div>
      </div>`);
    drawCoin(document.getElementById('coin'));
    document.getElementById('btnAgain').onclick=()=>doRestart();
    if(BRAND.ENABLE_FINAL_MODE) document.getElementById('btnFinal').onclick=()=>startFinal();
    document.getElementById('optA').onclick=()=>tinyShake();
    document.getElementById('optB').onclick=()=>tinyShake();
  }

  function showFinalWin(){
    wins+=1; localStorage.setItem(LS_WINS,String(wins));
    showOverlay(`
      <div>
        <div class="big" style="color:var(--gold)">🏆 ¡Dominaste la pista!</div>
        <div class="btns">
          <button class="btn" id="btnPlayBase">Nivel base</button>
          <button class="btn" id="btnPlayFinal">Repetir Final</button>
        </div>
      </div>`);
    document.getElementById('btnPlayBase').onclick=()=>doRestart();
    document.getElementById('btnPlayFinal').onclick=()=>startFinal();
  }

  function doRestart(){ hideOverlay(); reset(true); }
  function startFinal(){ resetFinal(); }

  // Coin
  function drawCoin(canvasEl){
    const c=canvasEl.getContext('2d'); const Wc=canvasEl.width, Hc=canvasEl.height; let t=0; let face = rndInt(0,3);
    const render=()=>{ const dt=1/60; t+=dt; c.clearRect(0,0,Wc,Hc); c.save(); c.translate(Wc/2,Hc/2); const flip=Math.abs(Math.cos(t*4)); const sx=lerp(.15,1,flip); c.scale(sx,1);
      const r=100; const grad=c.createRadialGradient(0,0,10,0,0,r); grad.addColorStop(0,'#fff1'); grad.addColorStop(1,'#f6c55a'); c.fillStyle=grad; c.beginPath(); c.arc(0,0,r,0,Math.PI*2); c.fill(); c.lineWidth=6; c.strokeStyle='rgba(0,0,0,.25)'; c.stroke();
      c.save(); c.beginPath(); c.arc(0,0,r-16,0,Math.PI*2); c.clip(); const im=charImgs[face]; if(charReady[face]) c.drawImage(im,-r,-r,2*r,2*r); else { c.fillStyle='#fff2'; c.fillRect(-r,-r,2*r,2*r); } c.restore(); c.restore(); requestAnimationFrame(render); };
    canvasEl.addEventListener('click',()=>{ t+=.8; });
    render();
  }

  // ====== Spawner ======
  function nextToken(p){ if(tokenQueue.length===0){ tokenQueue = pickPattern(p); } return tokenQueue.shift(); }
  function spawnFromToken(tok){
    const gx=W+20, gy=groundY;
    switch(tok){
      case 'S': makeGlass(gx, gy, 56*K, 92*K); break;
      case 'D': makeGlass(gx, gy, 56*K, 92*K); makeGlass(gx+120*K, gy, 56*K, 96*K); break;
      case 'G': makeHighGlass(gx, gy); break;
      case 'B': makeBottle(gx, gy); break;
      case 'P': makePerson(gx, gy); break;
      case 'M': makeSpeakerWave(gx, gy); break;
      case 'V': makeRope(gx, gy); break;
      case 'X': makeBox(gx, gy); break;
      default: break;
    }
  }

  // ====== Obstáculos helpers (todos escalados por K) ======
  function allocObs(){ for(let i=0;i<OBS_MAX;i++) if(!obs[i].active) return obs[i]; return obs[0]; }
  function makeGlass(x,gy,w=56*K,h=92*K){ const o=allocObs(); o.type='glass'; o.active=true; o.x=x; o.w=w|0; o.h=h|0; o.y=gy-o.h; o.baseY=o.y; }
  function makeHighGlass(x,gy){ makeGlass(x,gy,64*K,112*K); }
  function makeBottle(x,gy){ const o=allocObs(); o.type='bottle'; o.active=true; o.x=x; o.w=(50*K)|0; o.h=(150*K)|0; o.y=gy-o.h; o.baseY=o.y; }
  function makePerson(x,gy){ const o=allocObs(); o.type='person'; o.active=true; o.x=x; o.w=(66*K)|0; o.h=(126*K)|0; o.baseY=gy-o.h-(28*K); o.y=o.baseY; o.amp=28*K; o.t=rand(0,Math.PI*2); }
  function makeSpeakerWave(x,gy){ const o=allocObs(); o.type='music'; o.active=true; o.x=x; o.w=(70*K)|0; o.h=(110*K)|0; o.baseY=gy-o.h-(40*K); o.y=o.baseY; o.amp=38*K; o.t=rand(0,Math.PI*2); }
  function makeRope(x,gy){ const o=allocObs(); o.type='rope'; o.active=true; o.x=x; o.w=(120*K)|0; o.h=(44*K)|0; o.y=gy-o.h; }
  function makeBox(x,gy){ const o=allocObs(); o.type='box'; o.active=true; o.x=x; o.w=(120*K)|0; o.h=(70*K)|0; o.y=gy-o.h-(26*K); o.baseY=o.y; }

  // ====== Colisiones ======
  const aabb=(px,py,pw,ph,ox,oy,ow,oh)=> (px<ox+ow && px+pw>ox && py<oy+oh && py+ph>oy);

  // ====== DIBUJO ======
  function drawBackground(dt,camX){
    const t=performance.now()/1000;
    const c1=`hsl(${(t*40)%360} 80% 10%)`; const c2=`hsl(${(t*40+120)%360} 80% 8%)`; const c3=`hsl(${(t*40+240)%360} 80% 6%)`;
    const sky=ctx.createLinearGradient(0,0,0,H); sky.addColorStop(0,c1); sky.addColorStop(.5,c2); sky.addColorStop(1,c3); ctx.fillStyle=sky; ctx.fillRect(0,0,W,H);
    ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.globalAlpha=.25; for(let i=0;i<6;i++){ const y=(Math.sin(t*1.2+i)*.5+.5)*H*.6+H*.1; ctx.fillStyle=`hsl(${(i*60+t*120)%360} 100% 60% / .6)`; ctx.fillRect((i/6)*W, y, W/6, 6); } ctx.restore();
    const step=64*K; const scroll=(camX*.2)%step; ctx.save(); ctx.globalAlpha=.22; ctx.strokeStyle='rgba(214,203,255,.18)'; ctx.lineWidth=1; ctx.translate(-scroll,0);
    for(let x=0;x<W+step;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<H;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); } ctx.restore();

    const glow=ctx.createLinearGradient(0,groundY-(38*K),0,groundY+(12*K));
    glow.addColorStop(0,'rgba(139,92,246,.22)'); glow.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=glow; ctx.fillRect(0,groundY-(38*K),W,(50*K));
    ctx.fillStyle='#0a0f1a'; ctx.fillRect(0,groundY,W,H-groundY);
    ctx.fillStyle='#131b2a'; ctx.fillRect(0,groundY-(12*K),W,(12*K));
  }

  function roundRect(c,x,y,w,h,r){ const rr=Math.min(r,w/2,h/2); c.beginPath(); c.moveTo(x+rr,y); c.arcTo(x+w,y,x+w,y+h,rr); c.arcTo(x+w,y+h,x,y+h,rr); c.arcTo(x,y+h,x,y,rr); c.arcTo(x,y,x+w,y,rr); c.closePath(); }

  function drawObstacle(o){
    ctx.save(); ctx.shadowColor='rgba(0,0,0,.5)'; ctx.shadowBlur=18*K; let grad=ctx.createLinearGradient(o.x,o.y,o.x,o.y+o.h); grad.addColorStop(0,'#8b5cf6'); grad.addColorStop(1,'#00ffd5'); ctx.fillStyle=grad; ctx.strokeStyle='rgba(255,255,255,.15)';
    if(o.type==='glass'){
      ctx.beginPath(); ctx.moveTo(o.x, o.y+o.h); ctx.lineTo(o.x+o.w/2, o.y); ctx.lineTo(o.x+o.w, o.y+o.h); ctx.closePath(); ctx.fill(); ctx.stroke();
    } else if(o.type==='bottle'){
      const neckH=20*K; ctx.fillRect(o.x+o.w*.35, o.y-neckH, o.w*.3, neckH); ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeRect(o.x+.5, o.y+.5, o.w-1, o.h-1);
    } else if(o.type==='person'){
      const r=o.w*.34; ctx.beginPath(); ctx.arc(o.x+o.w/2, o.y+r, r, 0, Math.PI*2); ctx.fill(); ctx.fillRect(o.x+o.w*.28, o.y+r*2, o.w*.44, o.h-r*2);
    } else if(o.type==='music'){
      ctx.fillRect(o.x, o.y, o.w, o.h); for(let i=0;i<6;i++){ ctx.fillRect(o.x+i*(10*K), o.y-(10*K), (6*K), (10*K)); }
    } else if(o.type==='rope'){
      ctx.fillRect(o.x, o.y+o.h-(12*K), o.w, (12*K));
      ctx.beginPath(); ctx.moveTo(o.x+(12*K),o.y+o.h-(12*K)); ctx.lineTo(o.x+(12*K),o.y);
      ctx.moveTo(o.x+o.w-(12*K),o.y+o.h-(12*K)); ctx.lineTo(o.x+o.w-(12*K),o.y);
      ctx.lineWidth=6*K; ctx.strokeStyle='rgba(255,255,255,.25)'; ctx.stroke();
    } else if(o.type==='box'){
      const r=12*K; roundRect(ctx, o.x, o.y, o.w, o.h, r); ctx.fill(); ctx.stroke();
    } else { ctx.fillRect(o.x, o.y, o.w, o.h); }
    ctx.restore();
  }

  function drawPlayer(dt){
    for(let i=0;i<TRAIL_MAX;i++){ const p=trail[i]; if(p.a<=0) continue; p.a-=dt*1.8; if(p.a<0) p.a=0; ctx.save(); ctx.globalAlpha=p.a*.7; const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r); g.addColorStop(0,'rgba(214,203,255,.9)'); g.addColorStop(1,'rgba(139,92,246,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); ctx.restore(); }
    ctx.save(); ctx.translate(player.x+player.w/2, player.y+player.h/2); ctx.rotate(player.rotation);
    ctx.shadowColor='rgba(139,92,246,.85)'; ctx.shadowBlur= player.airborne ? 34*K : 18*K;
    const im=charImgs[chosenChar]; if(charReady[chosenChar]) ctx.drawImage(im,-player.w/2,-player.h/2,player.w,player.h);
    else { ctx.fillStyle='#d6cbff'; roundRect(ctx,-player.w/2,-player.h/2,player.w,player.h,14*K); ctx.fill(); }
    ctx.shadowBlur=0; ctx.restore();
  }

  function drawVictoryEffects(dt){
    for(let i=0;i<FW_MAX;i++){ const p=fw[i]; if(p.a<=0) continue; p.life-=dt; p.a=clamp(p.life,0,1); p.vy+=80*K*dt; p.x+=p.vx*dt; p.y+=p.vy*dt; ctx.save(); ctx.globalAlpha=p.a; ctx.fillStyle=`hsl(${p.hue} 100% 60%)`; ctx.beginPath(); ctx.arc(p.x,p.y,p.sz,0,Math.PI*2); ctx.fill(); ctx.restore(); }
    for(let i=0;i<CF_MAX;i++){ const c=cf[i]; if(c.a<=0) continue; c.vy+=30*K*dt; c.x+=c.vx*dt; c.y+=c.vy*dt; c.rot+=c.rvel*dt; if(c.y>H+20*K){ c.a=0; continue; } ctx.save(); ctx.globalAlpha=.9; ctx.translate(c.x,c.y); ctx.rotate(c.rot); ctx.fillStyle=`hsl(${c.hue} 100% 60%)`; ctx.fillRect(-c.w/2,-c.h/2,c.w,c.h); ctx.restore(); }
  }

  // Partículas helpers
  function spawnFirework(){ const ex=rand(W*.15,W*.85), ey=rand(H*.15,H*.45); const count=SETTINGS.FWAVE.count|0; for(let i=0;i<count;i++){ const p=allocFW(); const a=(i/count)*Math.PI*2+rand(-.04,.04); const sp=rand(80*K, SETTINGS.FWAVE.power*K); p.x=ex; p.y=ey; p.vx=Math.cos(a)*sp; p.vy=Math.sin(a)*sp; p.life=rand(.8,1.6); p.hue=rndInt(0,360); p.sz=rand(1.5*K,3.6*K); p.a=1; } }
  function allocFW(){ for(let i=0;i<FW_MAX;i++) if(fw[i].a<=0) return fw[i]; return fw[0]; }
  function spawnConfetti(dt){ let toSpawn=SETTINGS.CONFETTI.rate*dt; while(toSpawn>0){ const c=allocCF(); c.x=rand(40,W-40); c.y=-10; c.vy=rand(40*K,90*K); c.vx=rand(-20*K,20*K); c.rot=rand(0,Math.PI*2); c.rvel=rand(-2,2); c.w=rand(SETTINGS.CONFETTI.sizeMin*K, SETTINGS.CONFETTI.sizeMax*K); c.h=rand(SETTINGS.CONFETTI.sizeMin*K, SETTINGS.CONFETTI.sizeMax*K); c.hue=rndInt(0,360); c.a=1; toSpawn-=1; } }
  function allocCF(){ for(let i=0;i<CF_MAX;i++) if(cf[i].a<=0) return cf[i]; return cf[0]; }

  // ====== LOOP ======
  let fwTimer=0;
  function loop(ts){
    const dt=Math.min(1/20,(ts-lastTime)/1000); lastTime=ts; const wantR=keyR; keyR=false;
    if(state===STATE.MENU){ if(keyJump) showPick(); keyJump=false; }
    if(state===STATE.PICK){ /* overlay maneja */ }
    if(state===STATE.PLAY||state===STATE.FINAL){ update(dt); keyJump=false; }
    if(state===STATE.DEAD){ if(wantR) doRestart(); }
    if(state===STATE.WIN||state===STATE.FINAL_WIN){
      fwTimer-=dt; if(fwTimer<=0){ spawnFirework(); fwTimer=SETTINGS.FWAVE.spawnEvery; }
      spawnConfetti(dt);
      if(keyJump){ doRestart(); }
      keyJump=false;
    }

    const shake=(shakeT>0)?SETTINGS.SHAKE_MAX*(shakeT)*K:0; if(shakeT>0) shakeT=Math.max(0, shakeT-SETTINGS.SHAKE_DECAY*dt);
    ctx.save(); if(shake>0) ctx.translate(rand(-shake,shake), rand(-shake,shake));
    drawBackground(dt, distanceM*PX_PER_M);
    for(let i=0;i<OBS_MAX;i++) if(obs[i].active) drawObstacle(obs[i]);
    drawPlayer(dt); if(state===STATE.WIN||state===STATE.FINAL_WIN) drawVictoryEffects(dt);
    ctx.restore(); updateHUD(); requestAnimationFrame(loop);
  }

  function attemptJump(){
    if(coyoteT>0 || !player.airborne){ jump(); airJumpsUsed = 0; return true; }
    if(airJumpsUsed < SETTINGS.MAX_AIR_JUMPS){ jump(true); airJumpsUsed++; return true; }
    return false;
  }

  function update(dt){
    const len=isFinal?SETTINGS.FINAL_LEN:SETTINGS.LEVEL_LEN;
    const base=isFinal?SETTINGS.FINAL_BASE_SPEED:SETTINGS.BASE_SPEED;
    const end=isFinal?SETTINGS.FINAL_END_SPEED:SETTINGS.END_SPEED;
    progress=clamp(distanceM/len,0,1);
    speedMS=lerp(base,end,easeOutPow(progress,SETTINGS.ACCEL_EASE));
    distanceM+=speedMS*dt;

    const targetBPM=bpmForProgress(progress); beatDur=60/targetBPM; beatTimer-=dt; if(beatTimer<=0){ const tok=nextToken(progress)||'_'; spawnFromToken(tok); beatTimer+=beatDur; }

    const prevY = player.y;

    if(bufferT>0){ if(attemptJump()) bufferT=0; else bufferT-=dt; } else { bufferT-=dt; }

    if(player.airborne) coyoteT = Math.max(0, coyoteT - dt); else coyoteT = SETTINGS.COYOTE;
    player.vy += G*dt; player.y += player.vy*dt; const gy=groundY-player.h;
    if(player.y>=gy){ player.y=gy; player.vy=0; if(player.airborne){ coyoteT=SETTINGS.COYOTE; } player.airborne=false; airJumpsUsed=0; } else player.airborne=true;

    if(player.airborne){ player.rotation += clamp(player.vy/(900*K),-1.2,1.2)*dt*2.1; player.rotation = clamp(player.rotation,-0.6,0.6); } else { player.rotation *= Math.pow(0.001, dt); }

    const dx=speedMS*dt*PX_PER_M; for(let i=0;i<OBS_MAX;i++){ const o=obs[i]; if(!o.active) continue; o.x-=dx; if(o.type==='person' || o.type==='music'){ o.t+=dt*2; o.y = o.baseY + Math.sin(o.t) * o.amp; } if(o.x+o.w<-40*K) o.active=false; }

    trailTimer -= dt; if(trailTimer<=0){ const p=trail[trailIdx++%TRAIL_MAX]; p.x=player.x+player.w/2; p.y=player.y+player.h/2; p.a=1; p.r=rand(10*K,22*K); trailTimer=SETTINGS.TRAIL_INTERVAL; }

    const px=player.x, py=player.y, pw=player.w, ph=player.h; for(let i=0;i<OBS_MAX;i++){
      const o=obs[i]; if(!o.active) continue; if(!aabb(px,py,pw,ph,o.x,o.y,o.w,o.h)) continue;
      if(o.type==='box'){
        const tolerance = 10*K;
        if(prevY + ph <= o.y + tolerance && player.vy >= 0){ player.y = o.y - ph; player.vy = 0; player.airborne = false; airJumpsUsed=0; }
        else { state=STATE.DEAD; statusTag.textContent='DERROTA'; shakeT=1.0; showDeath(); break; }
      } else {
        state=STATE.DEAD; statusTag.textContent='DERROTA'; shakeT=1.0; showDeath(); break;
      }
    }

    if(progress>=1){
      if(!isFinal){ state=STATE.WIN; statusTag.textContent='VICTORIA'; showWin(); }
      else { state=STATE.FINAL_WIN; statusTag.textContent='VICTORIA'; showFinalWin(); }
    }
  }

  function jump(isAir=false){ player.vy=JUMP_V; player.airborne=true; if(isAir){ shakeT=Math.max(shakeT,.18); } }

  function updateHUD(){
    const pct=Math.floor(progress*100);
    progressBar.style.width=pct+'%';
    const dist=Math.floor(distanceM);
    const rec=Math.floor(Math.max(recordDistance,dist));
    statsEl.innerHTML = `Distancia: <b>${dist} m</b> · Récord: <b>${rec} m</b> · Ganadas: <b>${wins}</b> · <b>Doble salto</b>`;
  }

  function tinyShake(){ shakeT = Math.max(shakeT, .3); }

  // Resize/orientation
  fitCanvas();
  window.addEventListener('resize', fitCanvas);
  (window.visualViewport||window).addEventListener?.('resize', fitCanvas);
  window.addEventListener('orientationchange', ()=>{ setTimeout(fitCanvas, 250); reset(true); });

  // Inicio
  reset(true); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
